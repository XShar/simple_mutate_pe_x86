# simple_mutate_pe_x86

Пермутация - Это замена текущего кода, другим, но котоый делает те-же действия:

Смысл такой, вот есть у вас набор инструкций (Сложение, вычитание, деление, умножение и т.д.), эти инструкции можно использовать по разному, т.е. будет разный код, но действие одинаковое.

Для чего обычно используется преобразование кода? 

Для сокрытия важных частей алгоритма, для затруднения взлома и сигнатурного анализа. 

Глупо было бы думать, что этим трюком пользуются только легальные корпорации и фирмы. 

Разработчики вредоносного программного обеспечения прочно забронировали себе места в топе подобных достижений. 

Только используются они для сокрытия и затруднения анализа вирусов.

Пример мутации кода:

 Вот исходные инструкции:

    ;------------------------------------------------------------------------------; 
    	mov eax,12345678
    	add ecx,333
    ;------------------------------------------------------------------------------;

После процесса пермутации они станут примерно такими:

    ;------------------------------------------------------------------------------; 
    	mov eax,1
    	add eax,12345677
    	sub ecx,-333
    ;------------------------------------------------------------------------------;

Таким образом, сигнатурное детектирование становится практически невозможным. 

А после многоразового преобразования – и эмуляция тоже, поскольку этот процесс забирает значительно больше процессорного времени, чем прямое исполнение. 

Увеличение объема эмулируемого(или трассируемого) кода ставит антивирус или взломщика в неудобное положение, поскольку ограничение антивируса - это глубина эмуляции, а ограничение взломщика - время трассировки.  

Что делает данный движок ?

Считывает исполняемый файл в память (максимальный размер файла может-быть 50 мегабайт), далее получает указатель на секцию данных исполняемого файла, скармливает эти данные в движок от Зомбы (29А).

Что делает дижок от Зомбы ?

Смотрит опкоды дата секции, если он известны движку, то заменяет их оригиналами, пример кода:

if (inBuf[i] == 0x55)
			if (inBuf[i + 1] == 0x8B)
				if (inBuf[i + 2] == 0xEC)
					if (inBuf[i + 3] == 0x83) // add esp, -x
						if (inBuf[i + 4] == 0xC4)
							if (((char)inBuf[i + 5] <= 0) && (inBuf[i + 5] != 0x80)) // -128 sux
								if (rand() % 2 || MutAll)
								{
									inBuf[i] = 0xC8;
									inBuf[i + 1] = -inBuf[i + 5];
									inBuf[i + 2] = 0;
									inBuf[i + 3] = 0;
									inBuf[i + 4] = 0x90;
									inBuf[i + 5] = 0x90;
									++MutationCount;

								}
								
Как работать с движком:

1)Движок собран в Visual Studio 2017, но если вы нехотите собирать, то в папке Release\simple_mutate_pe.exe уже есть готовый бинарник simple_mutate_pe.exe.

2)Запустить start.cmd.

3)В консоле ввести simple_mutate_pe.exe <path_to_image>

Где <path_to_image> - Имя исполняемого файла, который нужно мутировать.

Если все прошло хорошо, то в текущем каталоге появится мутированный файл с приставкой Mutated_***

Файл должен обязательно находится в текущем каталоге движка, прямые пути не работают.

В папке Release примеры оригинального Putty и Mutated_Putty. 

Подводные камни:

1)Неоттестировано, т.к. написано было буквально за час.

2)Неработает с .NET и прочее.

3)Работает только с x86 PE файлами. 